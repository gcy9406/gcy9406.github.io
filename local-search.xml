<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>百度TSDB简单记录-NodeJs</title>
    <link href="/2020/08/10/%E7%99%BE%E5%BA%A6TSDB%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95-NodeJs/"/>
    <url>/2020/08/10/%E7%99%BE%E5%BA%A6TSDB%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95-NodeJs/</url>
    
    <content type="html"><![CDATA[<p>百度时序数据库NodeJs使用说明<br><a id="more"></a></p><blockquote><p><a href="https://cloud.baidu.com/doc/TSDB/s/7k0gi8ytb" target="_blank" rel="noopener">https://cloud.baidu.com/doc/TSDB/s/7k0gi8ytb</a></p></blockquote><h2 id="名称说明"><a href="#名称说明" class="headerlink" title="名称说明"></a>名称说明</h2><ol><li><p>度量（metric）</p><p>度量可以理解为数据库的表名</p></li><li><p>域（field）</p><p>域就是表中的字段（如一个传感器设备的温度、湿度等）</p></li><li><p>标签（tag）</p><p> 标签是表的主要字段（如一个传感器设备的序列号）</p></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install @baiducloud/sdk</code></pre><ul><li>简单使用</li></ul><pre><code>import {TsdbDataClient} from &#39;@baiducloud/sdk&#39;;  // 需要使用babel转义为 require关键字// 或者使用 var TsdbDataClient = require(&#39;@baiducloud/sdk&#39;).TsdbDataClient;const config = {    endpoint: &lt;Endpoint&gt;,                  // 用户的时序数据库域名，形式如 http://{databaseName}.tsdb.iot.gz.baidubce.com    credentials: {        ak: &lt;AccessKeyID&gt;,                //您的AccessKey        sk: &lt;SecretAccessKey&gt;              //您的SecretAccessKey    }};let client = new TsdbDataClient(config);client.getMetrics()                             // 调用所需要的的接口    .then(response =&gt; console.log(response))    // 成功    .catch(error =&gt; console.error(error));      // 失败</code></pre><ul><li>多域查询</li></ul><pre><code>// 构建想要查询的queryListvar queryList = [    {        &quot;metric&quot;: &quot;cpu_idle3&quot;,        &quot;fields&quot;: [ //结果中显示的域，要查哪些写哪些            &quot;field1&quot;,            &quot;field2&quot;        ],        &quot;tags&quot;: [ //结果中显示的tags,和域是一个数组，排列在域后面            &quot;rack&quot;,            &quot;host&quot;        ],        &quot;filters&quot;: { //过滤条件            &quot;start&quot;: &quot;5 hour ago&quot;, //开始于什么时间，也可以使用绝对时间戳            &quot;fields&quot;: [ //根据字段过滤                {                    &quot;field&quot;: &quot;field1&quot;,                    &quot;value&quot;: &quot;&gt;= 10&quot;                },                {                    &quot;field&quot;: &quot;field2&quot;,                    &quot;value&quot;: &quot;&lt;= 10&quot;                }            ],            &quot;tags&quot;: { //根据tag过滤，查询哪些tags的内容                &quot;rack&quot;: [                    &quot;rack1&quot;                ],                &quot;host&quot;: [                    &quot;server1&quot;                ]            },        },        &quot;groupBy&quot;: [//按tag进行分组            {                &quot;name&quot;: &quot;Tag&quot;,                &quot;tags&quot;: [                    &quot;rack&quot;,                    &quot;host&quot;                ]            }        ],        &quot;aggregators&quot;: [{ //聚合函数            &quot;name&quot;: &quot;Sum&quot;,//聚合函数类型            &quot;sampling&quot;: &quot;10 minutes&quot; //时间长度        }],          &quot;limit&quot;: 1000//限制查询的数量    }];// 获取并打印查询结果client.getDatapoints(&lt;queryList&gt;)    .then(response =&gt; console.log(JSON.stringify(response.body)))           // 获取成功    .catch(error =&gt; console.error(error)); </code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>TSDB</tag>
      
      <tag>百度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2020-07-17</title>
    <link href="/2020/07/17/%E9%9A%8F%E7%AC%942020-07-17/"/>
    <url>/2020/07/17/%E9%9A%8F%E7%AC%942020-07-17/</url>
    
    <content type="html"><![CDATA[<p>今天天气不错，大夏天的也不是很热。<br><a id="more"></a></p><p>今天老婆有转正的希望了，虽然她很是嫌弃现在的工作，但是转正不管怎么说也是一个千载难逢的好机会。</p><p>我只有一个愿望，就是不管怎么样，她能工作开心点，少点儿纠结。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转正</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql常用命令</title>
    <link href="/2020/07/15/MySql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/15/MySql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h2><a id="more"></a><h3 id="最简单的添加"><a href="#最简单的添加" class="headerlink" title="最简单的添加"></a>最简单的添加</h3><pre><code>ALTER ... ADD COLUMN...</code></pre><h3 id="在表的最后一列添加新的一项"><a href="#在表的最后一列添加新的一项" class="headerlink" title="在表的最后一列添加新的一项"></a>在表的最后一列添加新的一项</h3><pre><code>ALTER TABLE `tbname` ADD COLUMN `state` TINYINT(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0为添加1为编辑&#39; </code></pre><h3 id="在指定的位置添加新的一列"><a href="#在指定的位置添加新的一列" class="headerlink" title="在指定的位置添加新的一列"></a>在指定的位置添加新的一列</h3><pre><code>ALTER TABLE `tbname`ADD COLUMN `state` TINYINT(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0为添加1为编辑&#39; AFTER `column_name`;</code></pre><h3 id="在第一列添加新的一列"><a href="#在第一列添加新的一列" class="headerlink" title="在第一列添加新的一列"></a>在第一列添加新的一列</h3><pre><code>ALTER TABLE `tbname` ADD COLUMN `state` TINYINT(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0为添加1为编辑&#39; FIRST;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mosuitto常用命令</title>
    <link href="/2020/07/15/Mosuito%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/15/Mosuito%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="查看mosquitto的进程"><a href="#查看mosquitto的进程" class="headerlink" title="查看mosquitto的进程"></a>查看mosquitto的进程</h3><a id="more"></a><pre><code>ps -aux | grep mosquitto</code></pre><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><pre><code>kill -9 18248</code></pre><h3 id="启动mosquitto"><a href="#启动mosquitto" class="headerlink" title="启动mosquitto"></a>启动mosquitto</h3><pre><code>mosquitto -c /etc/mosquitto/mosquitto.conf -d</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mosquitto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改Bootstrap导航栏颜色</title>
    <link href="/2020/07/15/%E6%9B%B4%E6%94%B9Bootstrap%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%A2%9C%E8%89%B2/"/>
    <url>/2020/07/15/%E6%9B%B4%E6%94%B9Bootstrap%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%A2%9C%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<p>更改方式如下<br><a id="more"></a></p><pre><code>.navbar-custom {    background-color:#28323C;//导航条背景色    color:#ffffff;    border-radius:0;}.navbar-custom .navbar-nav &gt; li &gt; a {    color:#fff;}.navbar-custom .navbar-nav &gt; .active &gt; a {    color: #ffffff;    background-color:transparent;//选中的颜色}.navbar-custom .navbar-nav &gt; li &gt; a:hover,.navbar-custom .navbar-nav &gt; li &gt; a:focus,.navbar-custom .navbar-nav &gt; .active &gt; a:hover,.navbar-custom .navbar-nav &gt; .active &gt; a:focus,.navbar-custom .navbar-nav &gt; .open &gt;a {    text-decoration: none;    background-color: #e74c3c;//hover的颜色}.navbar-custom .navbar-brand {    color:#eeeeee;}.navbar-custom .navbar-toggle {    background-color:#eeeeee;}.navbar-custom .icon-bar {    background-color:#28323C;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootstrap</tag>
      
      <tag>导航栏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2教程</title>
    <link href="/2020/07/15/RxJava2%E6%95%99%E7%A8%8B/"/>
    <url>/2020/07/15/RxJava2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="RxJava2教程"><a href="#RxJava2教程" class="headerlink" title="RxJava2教程"></a>RxJava2教程</h1><a id="more"></a><blockquote><p><a href="https://juejin.im/post/5d983726f265da5b7a753cb7" target="_blank" rel="noopener">https://juejin.im/post/5d983726f265da5b7a753cb7</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很久之前就一直想整理一下rxjava，但是一直没有时间，最近是因为离职了，总算有时间整理一下了。因为打算每篇博客都记录一个框架。所以为了描述清楚，本篇博客可能略长（包含rxjava的简介，使用，背压，原理等），希望你们能认真的读完，收获肯定还是有的，也会采用大量的图来介绍，这样可以加深理解。也可以当一个工具博客，需要的使用的话随时查阅。</p><p>后续还会继续出背压和原理篇，敬请期待</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>什么是rxjava？ 是一种事件驱动的基于异步数据流的编程模式，整个数据流就像一条河流，它可以被观测（监听），过滤，操控或者与其他数据流合并为一条新的数据流。</p><p>三要素</p><ol><li><p>被观察者（Observable）</p></li><li><p>观察者（Observer）</p></li><li><p>订阅（subscribe）</p></li></ol><p>好了，因为秉持着要有图的思想，在介绍rxjava各个操作符的时候，会采用大量的图示来表示，图示来源于官方，这里先给大家介绍一下怎么看。<br>ok，进入到撸码环节</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="首先要在-build-gradle-文件中添加依赖"><a href="#首先要在-build-gradle-文件中添加依赖" class="headerlink" title="首先要在 build.gradle 文件中添加依赖"></a>首先要在 build.gradle 文件中添加依赖</h2><pre><code>implementation &#39;io.reactivex.rxjava2:rxjava:2.1.4&#39;implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.2&#39;</code></pre><h2 id="依赖搭建完毕了，我们先写个最简单的案例，一共3步走"><a href="#依赖搭建完毕了，我们先写个最简单的案例，一共3步走" class="headerlink" title="依赖搭建完毕了，我们先写个最简单的案例，一共3步走"></a>依赖搭建完毕了，我们先写个最简单的案例，一共3步走</h2><h3 id="创建被观察者"><a href="#创建被观察者" class="headerlink" title="创建被观察者"></a>创建被观察者</h3><pre><code>   // 创建被观察者   Observable.create(new ObservableOnSubscribe&lt;String&gt;() {       @Override       public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {            emitter.onNext(&quot;你好呀&quot;);            emitter.onNext(&quot;我爱中国&quot;);            emitter.onNext(&quot;祝愿祖国繁荣富强&quot;);            emitter.onComplete();        }   });</code></pre><h3 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h3><pre><code>   // 创建观察者   Observer observer = new Observer&lt;String&gt;(){       @Override       public void onSubscribe(Disposable d) {           Log.i(&quot;lybj&quot;, &quot;准备监听&quot;);       }       @Override       public void onNext(String s) {           Log.i(&quot;lybj&quot;, s);       }       @Override       public void onError(Throwable e) {           Log.i(&quot;lybj&quot;, &quot;error&quot;);       }       @Override       public void onComplete() {           Log.i(&quot;lybj&quot;, &quot;监听完毕&quot;);       }   };</code></pre><h3 id="订阅（也就是将被观察者和观察者关联）"><a href="#订阅（也就是将被观察者和观察者关联）" class="headerlink" title="订阅（也就是将被观察者和观察者关联）"></a>订阅（也就是将被观察者和观察者关联）</h3><pre><code>   // 订阅   observable.subscribe(observer);</code></pre><p>这就完事了，看下结果</p><p>是不是很简单，几个概念再介绍一下</p><p>onNext()：当被观察者(observable)通过调用onNext()发射数据的时候，观察者(observer)调用onNext()接收数据<br>onError()：当被观察者(observable)调用该函数时，观察者(observer)调用onError()，其他事件将不会继续发送<br>onComplete()：当被观察者(observable)调用该函数时，观察者(observer)调用onComplete()，其他事件将不会继续发送<br>其实rxjava，打个比方，就类似花洒的头，数据流就类似水流，它的被观察者（observable）的各种操作符就是花洒的那个头，可以有各种模式，比如中间喷水的，周围喷水的，喷水雾的等等。根据操作符的不同，可以改变数据的各种样式，根据花洒头的不同，可以把水流改成各种样式。 接下来，就来学习下observable的丰富的操作符。</p><h1 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h1><h2 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h2><h3 id="做啥的？"><a href="#做啥的？" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>创建被观察者对象</p><h3 id="如何用"><a href="#如何用" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>// 创建被观察者Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {                emitter.onNext(&quot;你好呀&quot;);                emitter.onNext(&quot;我爱中国&quot;);                emitter.onNext(&quot;祝愿祖国繁荣富强&quot;);                emitter.onComplete();            }        }).subscribe(new Observer&lt;String&gt;(){ // 关联观察者            @Override            public void onSubscribe(Disposable d) {                Log.i(&quot;lybj&quot;, &quot;准备监听&quot;);            }            @Override            public void onNext(String s) {                Log.i(&quot;lybj&quot;, s);            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;, &quot;error&quot;);            }            @Override            public void onComplete() {                Log.i(&quot;lybj&quot;, &quot;监听完毕&quot;);            }        });</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>可以直接链式调用关联观察者</p><h2 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h2><h3 id="做啥的？-1"><a href="#做啥的？-1" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>通过上面的图，应该很形象的说明了，主要作用就是创建一个被观察者，并发送事件，但是发送的事件不可以超过10个以上。</p><h3 id="如何用-1"><a href="#如何用-1" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.just(&quot;小明&quot;, &quot;小红&quot;, &quot;小兰&quot;).subscribe(new Observer&lt;String&gt;() {            @Override            public void onSubscribe(Disposable d) {                Log.i(&quot;lybj&quot;, &quot;准备监听&quot;);            }            @Override            public void onNext(String s) {                Log.i(&quot;lybj&quot;, s+&quot;来了&quot;);            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;, &quot;Error&quot;);            }            @Override            public void onComplete() {                Log.i(&quot;lybj&quot;, &quot;完毕&quot;);            }        });</code></pre><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><h2 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h2><h3 id="做啥的？-2"><a href="#做啥的？-2" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>当到指定时间后就会发送一个 0 的值给观察者。 在项目中，可以做一些延时的处理，类似于Handler中的延时</p><h3 id="如何用-2"><a href="#如何用-2" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.timer(2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() {        @Override        public void accept(Long aLong) throws Exception {             Log.i(&quot;lybj&quot;, aLong+&quot;&quot;);        }});</code></pre><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>延迟2秒后，将结果发送给观察者，Consumer和Observer是创建观察者的两种写法，相当于观察者中的onNext方法。</p><h2 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h2><h3 id="做啥的？-3"><a href="#做啥的？-3" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。 类似于项目中的timer，做计时器</p><h3 id="如何用-3"><a href="#如何用-3" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.interval(3,TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() {     @Override     public void accept(Long aLong) throws Exception {          Log.i(&quot;lybj&quot;, aLong+&quot;&quot;);     }});</code></pre><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><h2 id="intervalRange"><a href="#intervalRange" class="headerlink" title="intervalRange()"></a>intervalRange()</h2><h3 id="做啥的？-4"><a href="#做啥的？-4" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p><h3 id="如何用-4"><a href="#如何用-4" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.intervalRange(100, 4, 0, 10, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() {      @Override      public void accept(Long aLong) throws Exception {           Log.i(&quot;lybj&quot;, aLong+&quot;&quot;);      }});</code></pre><h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><p>参数依次是：开始值，循环执行的次数，初始延迟时间，执行间隔时间，时间单位</p><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><h3 id="做啥的？-5"><a href="#做啥的？-5" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>同时发送一定范围的事件序列。</p><h3 id="如何用-5"><a href="#如何用-5" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.range(0,10).subscribe(new Consumer&lt;Integer&gt;() {    @Override    public void accept(Integer integer) throws Exception {         Log.i(&quot;lybj&quot;, integer+&quot;&quot;);    }});</code></pre><h3 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h3><h2 id="rangeLong"><a href="#rangeLong" class="headerlink" title="rangeLong()"></a>rangeLong()</h2><h3 id="做啥的？-6"><a href="#做啥的？-6" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>作用与 range() 一样，只是数据类型为 Long</p><h3 id="如何用-6"><a href="#如何用-6" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code>Observable.rangeLong(0,10).subscribe(new Consumer&lt;Long&gt;() {    @Override    public void accept(Long aLong) throws Exception {         Log.i(&quot;lybj&quot;, aLong+&quot;&quot;);    }});</code></pre><h3 id="结果-6"><a href="#结果-6" class="headerlink" title="结果"></a>结果</h3><h2 id="empty-amp-never-amp-error"><a href="#empty-amp-never-amp-error" class="headerlink" title="empty() &amp; never() &amp; error()"></a>empty() &amp; never() &amp; error()</h2><h3 id="做啥的？-7"><a href="#做啥的？-7" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>never()：不发送任何事件<br>error()：发送 onError() 事件<br>empty() ： 直接发送 onComplete() 事件</p><h3 id="如何用-7"><a href="#如何用-7" class="headerlink" title="如何用?"></a>如何用?</h3><pre><code> private void  empty_never_error(){        Observable.empty().subscribe(new Observer(){            @Override            public void onSubscribe(Disposable d) {                Log.i(&quot;lybj&quot;, &quot;准备监听&quot;);            }            @Override            public void onNext(Object o) {                Log.i(&quot;lybj&quot;, o+&quot;&quot;);            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;, &quot;onError&quot;);            }            @Override            public void onComplete() {                Log.i(&quot;lybj&quot;, &quot;onComplete&quot;);            }        });</code></pre><h3 id="结果-7"><a href="#结果-7" class="headerlink" title="结果"></a>结果</h3><p>如果是empty() 则：</p><p>如果是error() 则：</p><p>如果是never()则：</p><h1 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><h3 id="做啥的？-8"><a href="#做啥的？-8" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>map 可以将被观察者发送的数据类型转变成其他的类型</p><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(&quot;中国&quot;, &quot;祖国&quot;, &quot;中国军人&quot;)                .map(new Function&lt;String, String&gt;() {                    @Override                    public String apply(String s) throws Exception {                        return &quot;我爱&quot; + s;                    }                })                .subscribe(new Consumer&lt;String&gt;() {                    @Override                    public void accept(String s) throws Exception {                        Log.i(&quot;lybj&quot;, s);                    }                });</code></pre><h3 id="结果-8"><a href="#结果-8" class="headerlink" title="结果"></a>结果</h3><p>简单来讲，就是可以对发射过来的数据进行再加工，再传给观察者</p><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h2><h3 id="做啥的？-9"><a href="#做啥的？-9" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。 flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable，map()只是返回数据，如果在元素再加工的时候，想再使用上面的创建操作符的话，建议使用flatMap()，而非map()。</p><h3 id="怎么用？-1"><a href="#怎么用？-1" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code> Observable.just(&quot;中国&quot;, &quot;祖国&quot;, &quot;中国军人&quot;, &quot;贪官&quot;)                .flatMap(new Function&lt;String, ObservableSource&lt;String&gt;&gt;() {                    @Override                    public ObservableSource&lt;String&gt; apply(String s) throws Exception {                        if(s.equals(&quot;贪官&quot;)){                            return Observable.error(new Exception(&quot;贪官不能被喜欢&quot;));                        }                        return Observable.just(&quot;我爱&quot;+s);                    }                })                .subscribe(new Consumer&lt;String&gt;() {                    @Override                    public void accept(String s) throws Exception {                        Log.i(&quot;lybj&quot;, s);                    }                }, new Consumer&lt;Throwable&gt;() {                    @Override                    public void accept(Throwable throwable) throws Exception {                        Log.i(&quot;lybj&quot;, throwable.getMessage());                    }                });</code></pre><h3 id="结果-9"><a href="#结果-9" class="headerlink" title="结果"></a>结果</h3><p>new Consumer方法监听的是Observable.error()</p><h2 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h2><h3 id="做啥的？-10"><a href="#做啥的？-10" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。</p><h3 id="怎么用？-2"><a href="#怎么用？-2" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(&quot;中国&quot;, &quot;祖国&quot;, &quot;中国军人&quot;, &quot;贪官&quot;)                .concatMap(new Function&lt;String, ObservableSource&lt;String&gt;&gt;() {                    @Override                    public ObservableSource&lt;String&gt; apply(String s) throws Exception {                        if(s.equals(&quot;贪官&quot;)){                            return Observable.error(new Exception(&quot;贪官不能被喜欢&quot;));                        }                        return Observable.just(&quot;我爱&quot;+s);                    }                })                .subscribe(new Consumer&lt;String&gt;() {                    @Override                    public void accept(String s) throws Exception {                        Log.i(&quot;lybj&quot;, s);                    }                }, new Consumer&lt;Throwable&gt;() {                    @Override                    public void accept(Throwable throwable) throws Exception {                        Log.i(&quot;lybj&quot;, throwable.getMessage());                    }                });</code></pre><h3 id="结果-10"><a href="#结果-10" class="headerlink" title="结果"></a>结果</h3><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer()"></a>buffer()</h2><h3 id="做啥的？-11"><a href="#做啥的？-11" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p><h3 id="怎么用？-3"><a href="#怎么用？-3" class="headerlink" title="怎么用？"></a>怎么用？</h3><p>buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。</p><pre><code>Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)                .buffer(2,1)                .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() {                    @Override                    public void accept(List&lt;String&gt; strings) throws Exception {                        Log.d(&quot;lybj&quot;, &quot;缓冲区大小： &quot; + strings.size());                        for (String s : strings){                            Log.d(&quot;lybj&quot;,  s);                        }                    }                });</code></pre><h3 id="结果-11"><a href="#结果-11" class="headerlink" title="结果"></a>结果</h3><h2 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h2><h3 id="做啥的？-12"><a href="#做啥的？-12" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>将发射的数据通过一个函数进行变换，然后将变换后的结果作为参数跟下一个发射的数据一起继续通过那个函数变换，这样依次连续发射得到最终结果。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><pre><code>Observable.just(1, 2, 3, 4, 5)                .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {                    @Override                    public Integer apply(Integer integer, Integer integer2) throws Exception {                        Log.i(&quot;lybj&quot;, &quot;integer01: &quot; + integer + &quot; integer02: &quot;+ integer2);                        return integer + integer2;                    }                }).subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;, &quot;accept: &quot; + integer);                    }                });</code></pre><h3 id="结果-12"><a href="#结果-12" class="headerlink" title="结果"></a>结果</h3><p>简单来说，先将第一个元素返回给观察者，然后将1，2的和返给观察者，然后将上一次计算的和，当第一个元素，也就是3，第2个元素，是一直按顺序取值，取第3个元素也就是3，那么将，3+3 =6，返回给观察者，以此类推，将6作为第一个元素，第二个元素取值4，将6+4=10返回给观察者。</p><p>sacn操作符是遍历源Observable产生的结果，再按照自定义规则进行运算，依次输出每次计算后的结果给订阅者</p><h2 id="window"><a href="#window" class="headerlink" title="window()"></a>window()</h2><h3 id="做啥的？-13"><a href="#做啥的？-13" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>发送事件时，将这些事件分为按数量重新分组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p><p>window与buffer区别：window是把数据分割成了Observable，buffer是把数据分割成List</p><h3 id="如何用？"><a href="#如何用？" class="headerlink" title="如何用？"></a>如何用？</h3><pre><code>Observable.just(&quot;鲁班&quot;, &quot;孙尚香&quot;, &quot;亚索&quot;,&quot;火女&quot;,&quot;盖伦&quot;)                .window(2)                .subscribe(new Consumer&lt;Observable&lt;String&gt;&gt;() {                    @Override                    public void accept(Observable&lt;String&gt; stringObservable) throws Exception {                        Log.i(&quot;lybj&quot;, &quot;分组开始&quot;);                        stringObservable.subscribe(new Consumer&lt;String&gt;() {                            @Override                            public void accept(String s) throws Exception {                                Log.i(&quot;lybj&quot;, s);                            }                        });                    }                });</code></pre><h3 id="结果-13"><a href="#结果-13" class="headerlink" title="结果"></a>结果</h3><h1 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><h3 id="做啥的？-14"><a href="#做啥的？-14" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p><h3 id="怎么用？-4"><a href="#怎么用？-4" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>  private void concat(){        Observable.concat(                Observable.just(1, 2, 3),                Observable.just(4, 5),                Observable.just(6, 7),                Observable.just(8, 9))                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;, integer+&quot;&quot;);                    }                });    }</code></pre><h3 id="结果-14"><a href="#结果-14" class="headerlink" title="结果"></a>结果</h3><h2 id="concatArray"><a href="#concatArray" class="headerlink" title="concatArray()"></a>concatArray()</h2><h3 id="做啥的？-15"><a href="#做啥的？-15" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>与 concat() 作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p><h3 id="怎么用？-5"><a href="#怎么用？-5" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.concatArray(Observable.just(1, 2, 3, 4),                Observable.just(5, 6),                Observable.just(7, 8, 9, 10),                Observable.just(11, 12, 13),                Observable.just(14, 15),                Observable.just(16))                .subscribe(new Consumer&lt;Integer&gt;() {            @Override            public void accept(Integer integer) throws Exception {                Log.i(&quot;lybj&quot;, integer+&quot;&quot;);            }        });</code></pre><h3 id="结果-15"><a href="#结果-15" class="headerlink" title="结果"></a>结果</h3><h2 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h2><h3 id="做啥的？-16"><a href="#做啥的？-16" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>这个方法与 concat() 作用基本一样，但是 concat() 是串行发送事件，而 merge() 并行发送事件，也是只能发送4个。</p><h3 id="怎么用？-6"><a href="#怎么用？-6" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.merge(Observable.just(1, 2, 3, 4),                Observable.just(5, 6),                Observable.just(7, 8, 9, 10),                Observable.just(11, 12, 13))                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;, integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-16"><a href="#结果-16" class="headerlink" title="结果"></a>结果</h3><h2 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h2><h3 id="做啥的？-17"><a href="#做啥的？-17" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>zip操作符用于将多个数据源合并，并生成一个新的数据源。新生成的数据源严格按照合并前的数据源的数据发射顺序，并且新数据源的数据个数等于合并前发射数据个数最少的那个数据源的数据个数。</p><h3 id="怎么用？-7"><a href="#怎么用？-7" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.zip(Observable.just(1, 2, 3),                Observable.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;),                new BiFunction&lt;Integer, String, String&gt;(){                    @Override                    public String apply(Integer o1, String o2) throws Exception {                        return o1 +&quot;_&quot;+ o2;                    }                })                .subscribe(new Consumer&lt;String&gt;() {                    @Override                    public void accept(String o) throws Exception {                        Log.i(&quot;lybj&quot;, o);                    }                });</code></pre><h3 id="结果-17"><a href="#结果-17" class="headerlink" title="结果"></a>结果</h3><h2 id="startWith-amp-startWithArray"><a href="#startWith-amp-startWithArray" class="headerlink" title="startWith() &amp; startWithArray()"></a>startWith() &amp; startWithArray()</h2><h3 id="做啥的？-18"><a href="#做啥的？-18" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。 </p><h3 id="怎么用？-8"><a href="#怎么用？-8" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1, 2, 3)               .startWithArray(4, 5)               .subscribe(new Consumer&lt;Integer&gt;() {                   @Override                   public void accept(Integer integer) throws Exception {                       Log.i(&quot;lybj&quot;, integer+&quot;&quot;);                   }               });</code></pre><h3 id="结果-18"><a href="#结果-18" class="headerlink" title="结果"></a>结果</h3><h2 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h2><h3 id="做啥的？-19"><a href="#做啥的？-19" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>返回被观察者发送事件的数量。</p><h3 id="怎么用？-9"><a href="#怎么用？-9" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(2, 3, 4, 5, 6)                .count()                .subscribe(new Consumer&lt;Long&gt;() {                    @Override                    public void accept(Long aLong) throws Exception {                        Log.i(&quot;lybj&quot;, &quot;事件数量：&quot; + aLong);                    }                });</code></pre><h3 id="结果-19"><a href="#结果-19" class="headerlink" title="结果"></a>结果</h3><h1 id="功能操作符"><a href="#功能操作符" class="headerlink" title="功能操作符"></a>功能操作符</h1><h2 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h2><h3 id="做啥的？-20"><a href="#做啥的？-20" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>延迟一段事件发送事件。</p><h3 id="怎么用？-10"><a href="#怎么用？-10" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4)                .delay(3, TimeUnit.SECONDS)                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-20"><a href="#结果-20" class="headerlink" title="结果"></a>结果</h3><h2 id="周期函数"><a href="#周期函数" class="headerlink" title="周期函数"></a>周期函数</h2><h3 id="做啥的？-21"><a href="#做啥的？-21" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>doOnEach(): 每次发送事件之前都会回调这个方法</p><p>doOnNext(): Observable 每发送 onNext() 之前都会先回调这个方法。</p><p>doAfterNext(): Observable 每发送 onNext() 之后都会回调这个方法。</p><p>doOnComplete(): Observable 每发送 onComplete() 之前都会回调这个方法。</p><p>doOnError(): Observable 每发送 onError() 之前都会回调这个方法。</p><p>doOnSubscribe(): Observable 每发送 onSubscribe()之前都会回调这个方法。</p><p>doOnDispose(): 当调用 Disposable 的 dispose() 之后回调该方法。</p><p>doOnTerminate(): 在 onError 或者 onComplete 发送之前回调。</p><p>doAfterTerminate(): onError 或者 onComplete 发送之后回调。</p><p>doFinally(): 在所有事件发送完毕之后回调该方法。如果取消订阅之后doAfterTerminate()就不会被回调，而doFinally()无论怎么样都会被回调，且都会在事件序列的最后。</p><h3 id="怎么用？-11"><a href="#怎么用？-11" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {                emitter.onNext(1);                emitter.onNext(2);                emitter.onNext(3);                emitter.onComplete();            }        }).doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() {            @Override            public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnEach 方法执行了, 结果：&quot;+ integerNotification.getValue());            }        }).doOnNext(new Consumer&lt;Integer&gt;() {            @Override            public void accept(Integer integer) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnNext 方法执行了, 结果：&quot;+ integer);            }        }).doAfterNext(new Consumer&lt;Integer&gt;() {            @Override            public void accept(Integer integer) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doAfterNext 方法执行了, 结果：&quot;+ integer);            }        }).doOnComplete(new Action() {            @Override            public void run() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnComplete 方法执行了&quot;);            }        }).doOnError(new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnError 方法执行了&quot;);            }        }).doOnSubscribe(new Consumer&lt;Disposable&gt;() {            @Override            public void accept(Disposable disposable) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnSubscribe 方法执行了&quot;);            }        }).doOnDispose(new Action() {            @Override            public void run() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnDispose 方法执行了&quot;);            }        }).doOnTerminate(new Action() {            @Override            public void run() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doOnTerminate 方法执行了&quot;);            }        }).doAfterTerminate(new Action() {            @Override            public void run() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doAfterTerminate 方法执行了&quot;);            }        }).doFinally(new Action() {            @Override            public void run() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;doFinally 方法执行了&quot;);            }        }).subscribe(new Observer&lt;Integer&gt;() {            private Disposable disposable;            @Override            public void onSubscribe(Disposable d) {                disposable = d;                Log.i(&quot;lybj&quot;, &quot;------观察者onSubscribe()执行&quot;);            }            @Override            public void onNext(Integer integer) {                Log.i(&quot;lybj&quot;, &quot;------观察者onNext()执行：&quot;+integer);                if(integer == 2){//                    disposable.dispose(); // 取消订阅                }            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;, &quot;------观察者onError()执行&quot;);            }            @Override            public void onComplete() {                Log.i(&quot;lybj&quot;, &quot;------观察者onComplete()执行&quot;);            }        });</code></pre><h3 id="结果-21"><a href="#结果-21" class="headerlink" title="结果"></a>结果</h3><h2 id="onErrorReturn"><a href="#onErrorReturn" class="headerlink" title="onErrorReturn()"></a>onErrorReturn()</h2><h3 id="做啥的？-22"><a href="#做啥的？-22" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p><h3 id="怎么用？-12"><a href="#怎么用？-12" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {                emitter.onNext(&quot;小明：到&quot;);                emitter.onError(new IllegalStateException(&quot;error&quot;));                emitter.onNext(&quot;小方：到&quot;);            }        }).onErrorReturn(new Function&lt;Throwable, String&gt;() {            @Override            public String apply(Throwable throwable) throws Exception {                Log.i(&quot;lybj&quot;,  &quot;小红请假了&quot;);                return &quot;小李：到&quot;;            }        }).subscribe(new Observer&lt;String&gt;() {            @Override            public void onSubscribe(Disposable d) {            }            @Override            public void onNext(String s) {                Log.i(&quot;lybj&quot;,  s);            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;,  e.getMessage());            }            @Override            public void onComplete() {            }        });</code></pre><h3 id="结果-22"><a href="#结果-22" class="headerlink" title="结果"></a>结果</h3><h2 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext()"></a>onErrorResumeNext()</h2><h3 id="做啥的？-23"><a href="#做啥的？-23" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p><h3 id="怎么用？-13"><a href="#怎么用？-13" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {                emitter.onNext(&quot;小明&quot;);                emitter.onNext(&quot;小方&quot;);                emitter.onNext(&quot;小红&quot;);                emitter.onError(new NullPointerException(&quot;error&quot;));            }        }).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends String&gt;&gt;() {            @Override            public ObservableSource&lt;? extends String&gt; apply(Throwable throwable) throws Exception {                return Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);            }        }).subscribe(new Observer&lt;String&gt;() {            @Override            public void onSubscribe(Disposable d) {                Log.i(&quot;lybj&quot;,  &quot;准备监听&quot;);            }            @Override            public void onNext(String s) {                Log.i(&quot;lybj&quot;,  s);            }            @Override            public void onError(Throwable e) {                Log.i(&quot;lybj&quot;,  e.getMessage());            }            @Override            public void onComplete() {                Log.i(&quot;lybj&quot;,  &quot;onComplete&quot;);            }        });</code></pre><h3 id="结果-23"><a href="#结果-23" class="headerlink" title="结果"></a>结果</h3><h2 id="onExceptionResumeNext"><a href="#onExceptionResumeNext" class="headerlink" title="onExceptionResumeNext()"></a>onExceptionResumeNext()</h2><h3 id="做啥的？-24"><a href="#做啥的？-24" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p><h3 id="怎么用？-14"><a href="#怎么用？-14" class="headerlink" title="怎么用？"></a>怎么用？</h3><p>Observable.create(new ObservableOnSubscribe<string>() {</string></p><pre><code>        @Override        public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {            emitter.onNext(&quot;小明&quot;);            emitter.onNext(&quot;小方&quot;);            emitter.onNext(&quot;小红&quot;);            emitter.onError(new Error(&quot;error&quot;));        }    }).onExceptionResumeNext(new Observable&lt;String&gt;() {        @Override        protected void subscribeActual(Observer observer) {            observer.onNext(&quot;小张&quot;);        }    }).subscribe(new Observer&lt;String&gt;() {        @Override        public void onSubscribe(Disposable d) {            Log.i(&quot;lybj&quot;,  &quot;准备监听&quot;);        }        @Override        public void onNext(String s) {            Log.i(&quot;lybj&quot;,  s);        }        @Override        public void onError(Throwable e) {            Log.i(&quot;lybj&quot;,  e.getMessage());        }        @Override        public void onComplete() {            Log.i(&quot;lybj&quot;,  &quot;onComplete&quot;);        }    });</code></pre><h3 id="结果-24"><a href="#结果-24" class="headerlink" title="结果"></a>结果</h3><h2 id="retry"><a href="#retry" class="headerlink" title="retry()"></a>retry()</h2><h3 id="做啥的？-25"><a href="#做啥的？-25" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p><h3 id="怎么用？-15"><a href="#怎么用？-15" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {                emitter.onNext(&quot;1&quot;);                emitter.onNext(&quot;2&quot;);                emitter.onError(new IllegalStateException());            }        }).retry(2)          .subscribe(new Observer&lt;String&gt;() {              @Override              public void onSubscribe(Disposable d) {                  Log.i(&quot;lybj&quot;,  &quot;准备监听&quot;);              }              @Override              public void onNext(String s) {                  Log.i(&quot;lybj&quot;,  s);              }              @Override              public void onError(Throwable e) {                  Log.i(&quot;lybj&quot;,  e.getMessage());              }              @Override              public void onComplete() {                  Log.i(&quot;lybj&quot;,  &quot;onComplete&quot;);              }          });</code></pre><h3 id="结果-25"><a href="#结果-25" class="headerlink" title="结果"></a>结果</h3><h2 id="retryUntil"><a href="#retryUntil" class="headerlink" title="retryUntil()"></a>retryUntil()</h2><h3 id="做啥的？-26"><a href="#做啥的？-26" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。</p><h3 id="怎么用？-16"><a href="#怎么用？-16" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            public void subscribe(@NonNull ObservableEmitter&lt;String&gt; emitter){                emitter.onNext(&quot;1&quot;);                emitter.onNext(&quot;2&quot;);                emitter.onNext(&quot;3&quot;);                emitter.onError(new NullPointerException(&quot;error&quot;));                emitter.onNext(&quot;4&quot;);                emitter.onNext(&quot;5&quot;);            }        }).retryUntil(new BooleanSupplier() {            @Override            public boolean getAsBoolean() throws Exception {                Log.i(&quot;lybj&quot;,  &quot;getAsBoolean&quot;);                return true;            }        }).subscribe(new Observer&lt;String&gt;() {            @Override            public void onSubscribe(Disposable d) {            }            @Override            public void onNext(String s) {                Log.i(&quot;lybj&quot;,  s);            }            @Override            public void onError(Throwable e) {            }            @Override            public void onComplete() {            }        });</code></pre><h3 id="结果-26"><a href="#结果-26" class="headerlink" title="结果"></a>结果</h3><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><h3 id="做啥的？-27"><a href="#做啥的？-27" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>重复发送被观察者的事件，times 为发送次数。</p><h3 id="怎么用？-17"><a href="#怎么用？-17" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3)                .repeat(2)                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-27"><a href="#结果-27" class="headerlink" title="结果"></a>结果</h3><h2 id="subscribeOn-amp-observeOn"><a href="#subscribeOn-amp-observeOn" class="headerlink" title="subscribeOn() &amp; observeOn()"></a>subscribeOn() &amp; observeOn()</h2><h3 id="做啥的？-28"><a href="#做啥的？-28" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>subscribeOn(): 指定被观察者的线程，如果多次调用此方法，只有第一次有效。 observeOn(): 指定观察者的线程</p><h3 id="怎么用？-18"><a href="#怎么用？-18" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            public void subscribe(@NonNull ObservableEmitter&lt;String&gt; emitter){                emitter.onNext(&quot;1&quot;);                Log.i(&quot;lybj&quot;,  Thread.currentThread().getName());            }        }).subscribeOn(Schedulers.io())          .observeOn(Schedulers.newThread())          .subscribe(new Consumer&lt;String&gt;() {               @Override               public void accept(String s) throws Exception {                   Log.i(&quot;lybj&quot;,  s);                   Log.i(&quot;lybj&quot;,  Thread.currentThread().getName());               }          });</code></pre><h3 id="结果-28"><a href="#结果-28" class="headerlink" title="结果"></a>结果</h3><h1 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><h3 id="做啥的？-29"><a href="#做啥的？-29" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>如果返回 true 则会发送事件，否则不会发送</p><h3 id="怎么用？-19"><a href="#怎么用？-19" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4,5)          .filter(new Predicate&lt;Integer&gt;() {                    @Override                    public boolean test(Integer integer) throws Exception {                        if(integer &gt; 4){                            return true;                        }                        return false;                    }           }).subscribe(new Consumer&lt;Integer&gt;() {               @Override               public void accept(Integer integer) throws Exception {                   Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);               }          });</code></pre><h3 id="结果-29"><a href="#结果-29" class="headerlink" title="结果"></a>结果</h3><h2 id="ofType"><a href="#ofType" class="headerlink" title="ofType()"></a>ofType()</h2><h3 id="做啥的？-30"><a href="#做啥的？-30" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>可以过滤不符合该类型事件</p><h3 id="怎么用？-20"><a href="#怎么用？-20" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1, 2, 3, &quot;小明&quot;, &quot;小方&quot;)                .ofType(String.class)                .subscribe(new Consumer&lt;String&gt;() {                    @Override                    public void accept(String s) throws Exception {                        Log.i(&quot;lybj&quot;,  s+&quot;&quot;);                    }                });</code></pre><h3 id="结果-30"><a href="#结果-30" class="headerlink" title="结果"></a>结果</h3><h2 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h2><h3 id="做啥的？-31"><a href="#做啥的？-31" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>跳过正序某些事件，count 代表跳过事件的数量</p><h3 id="怎么用？-21"><a href="#怎么用？-21" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4,5,6,7)                .skip(2)                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-31"><a href="#结果-31" class="headerlink" title="结果"></a>结果</h3><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h2><h3 id="做啥的？-32"><a href="#做啥的？-32" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>过滤事件序列中的重复事件。</p><h3 id="做啥的？-33"><a href="#做啥的？-33" class="headerlink" title="做啥的？"></a>做啥的？</h3><pre><code>Observable.just(1,2,3,1,4,1,2)                .distinct()                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-32"><a href="#结果-32" class="headerlink" title="结果"></a>结果</h3><h2 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged()"></a>distinctUntilChanged()</h2><h3 id="做啥的？-34"><a href="#做啥的？-34" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>过滤掉连续重复的事件</p><h3 id="做啥的？-35"><a href="#做啥的？-35" class="headerlink" title="做啥的？"></a>做啥的？</h3><pre><code>Observable.just(1,2,3,3,1,5,6)        .distinctUntilChanged()        .subscribe(new Consumer&lt;Integer&gt;() {            @Override            public void accept(Integer integer) throws Exception {                Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);            }        });</code></pre><h3 id="结果-33"><a href="#结果-33" class="headerlink" title="结果"></a>结果</h3><h2 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h2><h3 id="做啥的？-36"><a href="#做啥的？-36" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>控制观察者接收的事件的数量。</p><h3 id="怎么用？-22"><a href="#怎么用？-22" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code> Observable.just(1,2,3,4,5,6)                .take(3)                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-34"><a href="#结果-34" class="headerlink" title="结果"></a>结果</h3><h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce()"></a>debounce()</h2><h3 id="做啥的？-37"><a href="#做啥的？-37" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。 简单来说就是防抖动，比如按钮控制快速点击等。</p><h3 id="怎么用？-23"><a href="#怎么用？-23" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4,5)                .map(new Function&lt;Integer, Integer&gt;() {                    @Override                    public Integer apply(Integer integer) throws Exception {                        Thread.sleep(900);                        return integer;                    }                })                .debounce(1,TimeUnit.SECONDS)                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-35"><a href="#结果-35" class="headerlink" title="结果"></a>结果</h3><h2 id="firstElement-amp-amp-lastElement-amp-amp-elementAt"><a href="#firstElement-amp-amp-lastElement-amp-amp-elementAt" class="headerlink" title="firstElement() &amp;&amp; lastElement() &amp;&amp; elementAt()"></a>firstElement() &amp;&amp; lastElement() &amp;&amp; elementAt()</h2><h3 id="做啥的？-38"><a href="#做啥的？-38" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>firstElement(): 取事件序列的第一个元素。</p><p>lastElement(): 取事件序列的最后一个元素。</p><p>elementAt(): 以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。</p><h3 id="怎么用？-24"><a href="#怎么用？-24" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4)                .firstElement()                .subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-36"><a href="#结果-36" class="headerlink" title="结果"></a>结果</h3><h1 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h1><p>1.all()</p><h3 id="做啥的？-39"><a href="#做啥的？-39" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p><h3 id="怎么用？-25"><a href="#怎么用？-25" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1, 2, 3, 4, 5)                .all(new Predicate&lt;Integer&gt;() {                    @Override                    public boolean test(Integer integer) throws Exception {                        return integer &lt;= 4;                    }                }).subscribe(new Consumer&lt;Boolean&gt;() {            @Override            public void accept(Boolean aBoolean) throws Exception {                Log.i(&quot;lybj&quot;,  aBoolean+&quot;&quot;);            }        });</code></pre><h3 id="结果-37"><a href="#结果-37" class="headerlink" title="结果"></a>结果</h3><h2 id="takeWhile-amp-takeUntil"><a href="#takeWhile-amp-takeUntil" class="headerlink" title="takeWhile() &amp; takeUntil()"></a>takeWhile() &amp; takeUntil()</h2><h3 id="做啥的？-40"><a href="#做啥的？-40" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>takeWhile(): 从左边开始，将满足条件的元素取出来，直到遇到第一个不满足条件的元素，则终止 takeUntil(): 从左边开始，将满足条件的元素取出来，直到遇到第一个满足条件的元素，则终止 filter(): 是将所有满足条件的数据都取出。</p><h3 id="怎么用？-26"><a href="#怎么用？-26" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1, 2, 3, 4, 5)                .takeWhile(new Predicate&lt;Integer&gt;() {                    @Override                    public boolean test(Integer integer) throws Exception {                        return integer &lt; 3;                    }                }).subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结果-38"><a href="#结果-38" class="headerlink" title="结果"></a>结果</h3><h2 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile"></a>skipWhile</h2><h3 id="做啥的？-41"><a href="#做啥的？-41" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>从左边开始，根据条件跳过元素</p><h3 id="怎么用？-27"><a href="#怎么用？-27" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.just(1,2,3,4,5,3,2,1,7)                .skipWhile(new Predicate&lt;Integer&gt;() {                    @Override                    public boolean test(Integer integer) throws Exception {                        return integer &lt; 3;                    }                }).subscribe(new Consumer&lt;Integer&gt;() {                    @Override                    public void accept(Integer integer) throws Exception {                        Log.i(&quot;lybj&quot;,  integer+&quot;&quot;);                    }                });</code></pre><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><h2 id="isEmpty-amp-defaultIfEmpty"><a href="#isEmpty-amp-defaultIfEmpty" class="headerlink" title="isEmpty() &amp; defaultIfEmpty()"></a>isEmpty() &amp; defaultIfEmpty()</h2><h3 id="做啥的？-42"><a href="#做啥的？-42" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>isEmpty(): 判断事件序列是否为空。</p><p>defaultIfEmpty(): 如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。</p><h3 id="怎么用？-28"><a href="#怎么用？-28" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            public void subscribe(@NonNull ObservableEmitter&lt;String&gt; emitter){                emitter.onComplete();            }        }).isEmpty()          .subscribe(new Consumer&lt;Boolean&gt;() {              @Override              public void accept(Boolean aBoolean) throws Exception {                  Log.i(&quot;lybj&quot;,  aBoolean+&quot;&quot;);              }          });</code></pre><h3 id="结果-39"><a href="#结果-39" class="headerlink" title="结果"></a>结果</h3><h2 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h2><h3 id="做啥的？-43"><a href="#做啥的？-43" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p><h3 id="怎么用？-29"><a href="#怎么用？-29" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>在Observable.just(1,2,3,4,5,6)                .contains(2)                .subscribe(new Consumer&lt;Boolean&gt;() {                    @Override                    public void accept(Boolean aBoolean) throws Exception {                        Log.i(&quot;lybj&quot;,  aBoolean+&quot;&quot;);                    }                });</code></pre><h3 id="结果-40"><a href="#结果-40" class="headerlink" title="结果"></a>结果</h3><h2 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual()"></a>sequenceEqual()</h2><h3 id="做啥的？-44"><a href="#做啥的？-44" class="headerlink" title="做啥的？"></a>做啥的？</h3><p>判断两个 Observable 发送的事件是否相同。</p><h3 id="怎么用？-30"><a href="#怎么用？-30" class="headerlink" title="怎么用？"></a>怎么用？</h3><pre><code>Observable.sequenceEqual(Observable.just(&quot;小明&quot;, &quot;小方&quot;, &quot;小李&quot;),                Observable.just(&quot;小明&quot;, &quot;小方&quot;, &quot;小李&quot;, &quot;小张&quot;))                .subscribe(new Consumer&lt;Boolean&gt;() {                    @Override                    public void accept(Boolean aBoolean) throws Exception {                        Log.i(&quot;lybj&quot;,  aBoolean+&quot;&quot;);                    }                });</code></pre><h3 id="结果-41"><a href="#结果-41" class="headerlink" title="结果"></a>结果</h3>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度地图GPS坐标转换</title>
    <link href="/2020/07/15/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEGPS%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/07/15/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEGPS%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>官方接口文档<br><a id="more"></a></p><p><br></p><blockquote><p><a href="http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition" target="_blank" rel="noopener">http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition</a></p></blockquote><p><br></p><p><img src="https://i.loli.net/2020/07/15/5XOqHcRpbk9nleF.jpg" srcset="/img/loading.gif" alt="&#39;&#39;"></p><p><img src="https://i.loli.net/2020/07/15/Cm8EVqd4A7geoHY.jpg" srcset="/img/loading.gif" alt="&#39;&#39;"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标</tag>
      
      <tag>gps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓4.0Bug</title>
    <link href="/2020/07/15/%E5%AE%89%E5%8D%934-0Bug/"/>
    <url>/2020/07/15/%E5%AE%89%E5%8D%934-0Bug/</url>
    
    <content type="html"><![CDATA[<p>修改gradle-&gt;wrapper-&gt;gradle-wrapper.properties中的gradle版本太新，可以缓存老版本。<br><a id="more"></a></p><pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.4-all.zip</code></pre><p>依赖也改成低版本</p><pre><code>dependencies {        classpath &#39;com.android.tools.build:gradle:3.6.2&#39;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS超出范围自动省略</title>
    <link href="/2020/07/15/CSS%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%E8%87%AA%E5%8A%A8%E7%9C%81%E7%95%A5/"/>
    <url>/2020/07/15/CSS%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%E8%87%AA%E5%8A%A8%E7%9C%81%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="通过css设置文字强制不换行超出用省略号"><a href="#通过css设置文字强制不换行超出用省略号" class="headerlink" title="通过css设置文字强制不换行超出用省略号"></a>通过css设置文字强制不换行超出用省略号</h3><a id="more"></a><pre><code>{    white-space: nowrap; //文本强制不换行；    text-overflow:ellipsis; //文本溢出显示省略号；    overflow:hidden; //溢出的部分隐藏；}</code></pre><h3 id="超出两行用省略号"><a href="#超出两行用省略号" class="headerlink" title="超出两行用省略号"></a>超出两行用省略号</h3><pre><code>{    overflow: hidden;    -webkit-line-clamp: 2;    text-overflow: ellipsis;    display: -webkit-box;    -webkit-box-orient: vertical;}</code></pre><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。<br>常见结合属性：</p><ol><li><p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p></li><li><p>-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p></li></ol><p>3.text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>换行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2020-07-15</title>
    <link href="/2020/07/15/%E9%9A%8F%E7%AC%942020-07-15/"/>
    <url>/2020/07/15/%E9%9A%8F%E7%AC%942020-07-15/</url>
    
    <content type="html"><![CDATA[<p>博客这个东西总是一会儿开始，一会儿停。</p><p>中间试过很多东西，但是却怎么也找不到hexo博客的感觉。</p><p>虽然很多不方便，但是真的能有满足感以及偶尔写一写东西的冲动。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】EggJs使用Oauth2</title>
    <link href="/2020/03/18/EggJs%E4%BD%BF%E7%94%A8Oauth2/"/>
    <url>/2020/03/18/EggJs%E4%BD%BF%E7%94%A8Oauth2/</url>
    
    <content type="html"><![CDATA[<p>Eggjs搭建Oauth2环境<br><a id="more"></a></p><blockquote><p><a href="https://www.jianshu.com/p/1fe043a700bf" target="_blank" rel="noopener">https://www.jianshu.com/p/1fe043a700bf</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eggjs</tag>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2020-03-17</title>
    <link href="/2020/03/17/%E9%9A%8F%E7%AC%942020-03-17/"/>
    <url>/2020/03/17/%E9%9A%8F%E7%AC%942020-03-17/</url>
    
    <content type="html"><![CDATA[<p>今日阳光明媚</p><a id="more"></a><p>一个好的天气真的能让人心情大好</p><p>你看，今天虽然烦心事很多，但是心情依旧不错</p><p>搞了一天半的oauth2，就是没有结果，不知道是哪里出了问题。不能这样下去了，先搁着了，要不然工作做不完了</p><p>好了，开始正式工作</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>随笔2020-03-16</title>
    <link href="/2020/03/16/%E9%9A%8F%E7%AC%942020-03-16/"/>
    <url>/2020/03/16/%E9%9A%8F%E7%AC%942020-03-16/</url>
    
    <content type="html"><![CDATA[<p>最近是不是都是起早了？<br><a id="more"></a><br>心情一直都不是很好，感觉很不在状态，工作没有什么激情，看东西也看不下去，看一会儿就相当浮躁。</p><p>不知道自己到底是什么样的人了。</p><p>明明自己非常想改变自己的学历，而且现在也有足够的时间。但是就是不想去学习，不想去看书。</p><p>经常幻想自己被录取的那一刻，但是却不付出任何的努力，还总是信誓旦旦的许下承诺。</p><p>9个月后可能自己会相当的难堪吧？</p><p>现在的生活真是平平无奇，感觉就是在蹉跎岁月，每天过着同样的生活，做着同样的事情，浪费的珍贵的岁月。可能过几年我会像现在一样后悔，为什么不在年轻的时候多一些努力，少一些遗憾吧！</p><p>今天还是把课捡起来吧，本来时间就不多，不能再浪费了。</p><p>为自己也实实在在的拼一次吧！（希望这句话，以后不要成为老婆的笑料）</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CentOS环境搭建</title>
    <link href="/2020/03/12/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/03/12/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：centos 6.5 系统<br>前端：vue<br>后端：eggjs</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h2><h3 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h3><pre><code>curl -sL https://rpm.nodesource.com/setup_8.x | bash -</code></pre><h3 id="安装-nodejs-1"><a href="#安装-nodejs-1" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><pre><code>yum install -y nodejs</code></pre><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><h3 id="设置源-1"><a href="#设置源-1" class="headerlink" title="设置源"></a>设置源</h3><pre><code>rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm</code></pre><h3 id="安装-nginx-1"><a href="#安装-nginx-1" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><pre><code>yum install nginx</code></pre><h3 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h3><pre><code>service nginx start</code></pre><h3 id="nginx-service-无法执行"><a href="#nginx-service-无法执行" class="headerlink" title="nginx service 无法执行"></a>nginx service 无法执行</h3><pre><code>vim /etc/selinux/config</code></pre><p>SELINUX=enforcing 改为 SELINUX=disabled<br>重启 reboot</p><h2 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h2><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><pre><code>wget http://download.redis.io/releases/redis-4.0.8.tar.gz</code></pre><h3 id="将-Redis-移动到根目录，方便找"><a href="#将-Redis-移动到根目录，方便找" class="headerlink" title="将 Redis 移动到根目录，方便找"></a>将 Redis 移动到根目录，方便找</h3><pre><code>mv redis-4.0.8.tar.gz /etc</code></pre><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><pre><code>tar xzf /etc/redis-4.0.8.tar.gz</code></pre><h3 id="删掉不需要的"><a href="#删掉不需要的" class="headerlink" title="删掉不需要的"></a>删掉不需要的</h3><pre><code>rm -rf /etc/redis-4.0.8.tar.gz</code></pre><h3 id="进入-Redis-文件夹"><a href="#进入-Redis-文件夹" class="headerlink" title="进入 Redis 文件夹"></a>进入 Redis 文件夹</h3><pre><code>cd redis-4.0.8</code></pre><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><pre><code>make #无法make将上面的4.0.8换成5.0.7</code></pre><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><pre><code>vim redis.conf</code></pre><p>开始远程连接</p><pre><code>#bind 127.0.0.1 //注释</code></pre><p>关闭保护模式</p><pre><code>preotected-mode no</code></pre><p>开启后台模式</p><pre><code>daemonize no</code></pre><h3 id="启动-redis"><a href="#启动-redis" class="headerlink" title="启动 redis"></a>启动 redis</h3><pre><code>src/redis-server redis.conf</code></pre><h3 id="打开开机启动配置文件"><a href="#打开开机启动配置文件" class="headerlink" title="打开开机启动配置文件"></a>打开开机启动配置文件</h3><pre><code>vim /etc/rc.local</code></pre><h3 id="添加-redis-开机启动"><a href="#添加-redis-开机启动" class="headerlink" title="添加 redis 开机启动"></a>添加 redis 开机启动</h3><pre><code>/etc/redis-4.0.8/src/redis-server /etc/redis-4.0.8/redis.conf</code></pre><blockquote><p>参考地址：<a href="https://www.jianshu.com/p/ea47015dfe3a" target="_blank" rel="noopener">https://www.jianshu.com/p/ea47015dfe3a</a></p></blockquote><h1 id="程序部署"><a href="#程序部署" class="headerlink" title="程序部署"></a>程序部署</h1><p>首先需要安装 git</p><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><pre><code>yum install git</code></pre><h3 id="创建文件文件夹"><a href="#创建文件文件夹" class="headerlink" title="创建文件文件夹"></a>创建文件文件夹</h3><pre><code>mkdir /www/webmkdir /www/server</code></pre><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><h3 id="进入-web-文件夹-clone-前端代码"><a href="#进入-web-文件夹-clone-前端代码" class="headerlink" title="进入 web 文件夹 clone 前端代码"></a>进入 web 文件夹 clone 前端代码</h3><pre><code>git clone http://用户名:密码@git地址</code></pre><h2 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h2><h3 id="进入-server-文件夹-clone-后端代码"><a href="#进入-server-文件夹-clone-后端代码" class="headerlink" title="进入 server 文件夹 clone 后端代码"></a>进入 server 文件夹 clone 后端代码</h3><pre><code>git clone http://用户名:密码@git地址</code></pre><h3 id="进入项目文件夹（如：test），安装依赖"><a href="#进入项目文件夹（如：test），安装依赖" class="headerlink" title="进入项目文件夹（如：test），安装依赖"></a>进入项目文件夹（如：test），安装依赖</h3><pre><code>npm install --production</code></pre><p>如果报错直接全部安装</p><pre><code>npm install</code></pre><h3 id="启动后台程序"><a href="#启动后台程序" class="headerlink" title="启动后台程序"></a>启动后台程序</h3><pre><code>npm start</code></pre><h2 id="配置-nginx-代理"><a href="#配置-nginx-代理" class="headerlink" title="配置 nginx 代理"></a>配置 nginx 代理</h2><h3 id="找到配置文件"><a href="#找到配置文件" class="headerlink" title="找到配置文件"></a>找到配置文件</h3><pre><code>cd  /etc/nginx/conf.d</code></pre><h3 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><pre><code>vim default.conf</code></pre><h3 id="添加前端代理"><a href="#添加前端代理" class="headerlink" title="添加前端代理"></a>添加前端代理</h3><pre><code>server {listen 8000;server_name 127.0.0.1;root /www/web/test_web; # 前端页面位置</code></pre><h3 id="前端界面代理"><a href="#前端界面代理" class="headerlink" title="前端界面代理"></a>前端界面代理</h3><pre><code>location / {    root /www/web/test_web; # 前端页面位置    try_files $uri $uri/ /index.html; # vue history模式专用}</code></pre><h3 id="前端接口代理"><a href="#前端接口代理" class="headerlink" title="前端接口代理"></a>前端接口代理</h3><pre><code>location /api/v1 {    proxy_pass http://localhost:7001 # 后台地址}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2020-03-12</title>
    <link href="/2020/03/12/%E9%9A%8F%E7%AC%942020-03-12/"/>
    <url>/2020/03/12/%E9%9A%8F%E7%AC%942020-03-12/</url>
    
    <content type="html"><![CDATA[<p>今天早上的天气很不错，心情也很不错，所以工作只简单的做了些，就去倒腾WordPress了。</p><p>但是下午开始，天气就转阴了。</p><p>说好的几天都是多云呢？这天气预报就没有准过。</p><p>天气不好，心情也不好。</p><p>WordPress搞了半天，感觉没意思，还是hexo香。</p><p>也不知道是这几天运动的原因，还是起得早原因，或者是两者的共同原因，这今天都感觉很累。特别是今天，感觉眼睛都要睁不开了。</p><p>搞得现在工作都不想做了，想打人！</p><p>算了，还是去洗把脸，清醒清醒吧，认真工作，认真生活！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>不知道为啥</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-12-31</title>
    <link href="/2019/12/31/%E9%9A%8F%E7%AC%942019-12-31/"/>
    <url>/2019/12/31/%E9%9A%8F%E7%AC%942019-12-31/</url>
    
    <content type="html"><![CDATA[<p>12月31日，2019年即将离去了。</p><p>2020年，以前是一个多么遥不可及的数字，现在却即将踏入这崭新的一年。</p><p>2019年对我而言，应该是此生最难忘的一年吧。</p><p>因为这一年，发生了两个极端的事情，一个极端开心，一个极端痛苦。</p><p>不详细说了…</p><p>愿2020一切都好！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辞旧迎新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-11-13</title>
    <link href="/2019/11/13/%E9%9A%8F%E7%AC%942019-11-13/"/>
    <url>/2019/11/13/%E9%9A%8F%E7%AC%942019-11-13/</url>
    
    <content type="html"><![CDATA[<p>本来封面想找一个大胖和大壮小时候的照片的，但是翻照片的时候却又受不了，还是来一张虎喵的，虎喵又捡了个大便宜。</p><p>最近真是穷疯了。</p><p>恰逢最近又是双十一，又花了不少钱，所以来记录一下最近这段苦逼的日子。</p><p>每个月的工资钱都不够还的，这个月初就还了一万多，马上月底了又要还一万多，信用卡、房贷…</p><p>龙泉的项目的钱说这个月能给，也一直在拖，这个月如果还不给，我也只能说抱歉了。就一万多块钱一直拖，真是无语。</p><p>今天空了是应该好好的整理下钱是怎么花出去的了，要不然每个月稀里糊涂的，日子没法过了。</p><p>日子虽然苦，但是还是有很多事情值得开心。</p><p>比如：大胖又恢复了往日雄风，肥的像个球，不得不控制他的饮食了，太能吃了。果然养猫还得舍得花钱。</p><p>我要努力工作，让公司强大些，我也多赚点，天天混日子的话，等着喝西北风了。</p><p>加油工作，加油学习，加油锻炼，加油爱老婆！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双十一</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQTT服务搭建</title>
    <link href="/2019/10/31/EMQTT%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/10/31/EMQTT%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://docs.emqx.io/broker/v3/cn/" target="_blank" rel="noopener">https://docs.emqx.io/broker/v3/cn/</a></p></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Ubuntu 16.04 LTS amd64(64bit)</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装所需要的依赖包"><a href="#安装所需要的依赖包" class="headerlink" title="安装所需要的依赖包"></a>安装所需要的依赖包</h2><pre><code>$ sudo apt update &amp;&amp; sudo apt install -y \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \software-properties-common</code></pre><h2 id="添加EMQ-X的官方密钥"><a href="#添加EMQ-X的官方密钥" class="headerlink" title="添加EMQ X的官方密钥"></a>添加EMQ X的官方密钥</h2><pre><code>$ curl -fsSL https://repos.emqx.io/gpg.pub | sudo apt-key add –$ sudo apt-key fingerprint 3E640D53pub   rsa2048 2019-04-10 [SC]    FC84 1BA6 3775 5CA8 487B  1E3C C0B4 0946 3E64 0D53uid           [ unknown] emqx team &lt;support@emqx.io&gt;</code></pre><p>如果没现pub…再添加一次</p><h2 id="使用以下命令设置-stable-存储库。-如果要添加-unstable-存储库，请在以下命令中的单词-stable-之后添加单词-unstable"><a href="#使用以下命令设置-stable-存储库。-如果要添加-unstable-存储库，请在以下命令中的单词-stable-之后添加单词-unstable" class="headerlink" title="使用以下命令设置 stable 存储库。 如果要添加 unstable 存储库，请在以下命令中的单词 stable 之后添加单词 unstable"></a>使用以下命令设置 stable 存储库。 如果要添加 unstable 存储库，请在以下命令中的单词 stable 之后添加单词 unstable</h2><pre><code>$ sudo add-apt-repository \    &quot;deb [arch=amd64] https://repos.emqx.io/emqx-ce/deb/ubuntu/ \    $(lsb_release -cs) \    stable&quot;</code></pre><h2 id="更新-apt-包索引"><a href="#更新-apt-包索引" class="headerlink" title="更新 apt 包索引"></a>更新 apt 包索引</h2><pre><code>$ sudo apt update</code></pre><h2 id="查询可用版本"><a href="#查询可用版本" class="headerlink" title="查询可用版本"></a>查询可用版本</h2><pre><code>$ sudo apt-cache madison emqx</code></pre><h2 id="使用第二列中的版本字符串安装特定版本，例如-3-2-6"><a href="#使用第二列中的版本字符串安装特定版本，例如-3-2-6" class="headerlink" title="使用第二列中的版本字符串安装特定版本，例如 3.2.6"></a>使用第二列中的版本字符串安装特定版本，例如 3.2.6</h2><pre><code>$ sudo apt install emqx=3.2.6</code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h2><h3 id="关闭匿名访问"><a href="#关闭匿名访问" class="headerlink" title="关闭匿名访问"></a>关闭匿名访问</h3><ul><li><p>打开/etc/emqx文件夹下的emqx.conf</p></li><li><p>设置allow_anonymous = false</p></li></ul><h3 id="开启用户名认证"><a href="#开启用户名认证" class="headerlink" title="开启用户名认证"></a>开启用户名认证</h3><pre><code>sudo emqx_ctl plugins load emqx_auth_username</code></pre><h3 id="添加认证用户"><a href="#添加认证用户" class="headerlink" title="添加认证用户"></a>添加认证用户</h3><pre><code>sudo emqx_ctl userssudo emqx_ctl users add 用户名 密码</code></pre><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><ul><li><p>打开/etc/eqmx文件夹下的acl.conf</p></li><li><p>找到以下内容</p><pre><code>  %% 允许 &#39;dashboard&#39; 用户订阅 &#39;$SYS/#&#39;  {allow, {user, &quot;dashboard&quot;}, subscribe, [&quot;$SYS/#&quot;]}.  %% 允许本机用户发布订阅全部主题  {allow, {ipaddr, &quot;127.0.0.1&quot;}, pubsub, [&quot;$SYS/#&quot;, &quot;#&quot;]}.  %% 拒绝除本机用户以外的其他用户订阅 &#39;$SYS/#&#39; 与 &#39;#&#39; 主题  {deny, all, subscribe, [&quot;$SYS/#&quot;, {eq, &quot;#&quot;}]}.  %% 允许上述规则以外的任何情形  {allow, all}.</code></pre></li><li><p>修改权限</p><p>  将{allow, {user, “dashboard”}, subscribe, [“$SYS/#”]}删除，不允许用户订阅统配符</p></li></ul><h1 id="设置集群"><a href="#设置集群" class="headerlink" title="设置集群"></a>设置集群</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>打开/etc/emqx/emq.conf，找到node.name</p><h2 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h2><pre><code>node.name=emq@局域网IP</code></pre><h2 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h2><pre><code>sudo emqx_ctl cluster join emq@主服务器</code></pre><h2 id="离开集群"><a href="#离开集群" class="headerlink" title="离开集群"></a>离开集群</h2><p>主动离开<br></p><pre><code>sudo emqx_ctl luseter leave &lt;br&gt;</code></pre><p>从集群中删除<br></p><pre><code>sudo emqx_ctl cluster force-leave emq@要删除的服务器</code></pre><h1 id="启动EMQX"><a href="#启动EMQX" class="headerlink" title="启动EMQX"></a>启动EMQX</h1><h2 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h2><pre><code>$ emqx start</code></pre><h2 id="systemctl-启动"><a href="#systemctl-启动" class="headerlink" title="systemctl 启动"></a>systemctl 启动</h2><pre><code>$ sudo systemctl start emqx</code></pre><h2 id="service-启动"><a href="#service-启动" class="headerlink" title="service 启动"></a>service 启动</h2><pre><code>$ sudo service emqx start</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信公众号支付记录</title>
    <link href="/2019/10/31/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/10/31/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="微信支付环境"><a href="#微信支付环境" class="headerlink" title="微信支付环境"></a>微信支付环境</h1><h2 id="在微信支付后台配置好支付目录"><a href="#在微信支付后台配置好支付目录" class="headerlink" title="在微信支付后台配置好支付目录"></a>在微信支付后台配置好支付目录</h2><p>在微信商户平台（pay.weixin.qq.com）设置您的公众号支付支付目录，设置路径：商户平台–&gt;产品中心–&gt;开发配置.</p><p>公众号支付需要配置支付授权目录，将在这个目录里面发起支付，如果不设置是无法调用微信支付的。<br>如：<a href="http://www.hhhub.cn/wechat/pay" target="_blank" rel="noopener">http://www.hhhub.cn/wechat/pay</a><br><img src="http://www.hhhub.cn:8000/f/f9a4a2c1e1/?raw=1" srcset="/img/loading.gif" alt="wechat_pay"></p><h2 id="公众号后台配置"><a href="#公众号后台配置" class="headerlink" title="公众号后台配置"></a>公众号后台配置</h2><p>公众号支付必须要有openid才行，这里需要在公众号配置网页授权域名。<br>这里需要让微信能够访问到txt中的内容。<br><img src="http://www.hhhub.cn:8000/f/1088f751ae/?raw=1" srcset="/img/loading.gif" alt="wechat_pay"></p><p>使用nodejs可以简单实现</p><pre><code>var  http  =  require(&#39;http&#39;);  http.createServer(function  (request,  response)  {      response.writeHead(200,  {&#39;Content-Type&#39;:  &#39;text/html;  charset=utf-8&#39;});      if(request.url!==&quot;/favicon.ico&quot;){        response.write(&#39;txt的内容&#39;); //这里填写微信给的文本内容         response.end();     }  }).listen(80);  console.log(&#39;Server  running  at  http://127.0.0.1:8000/&#39;);  </code></pre><p>执行以上代码，就可以配置成功。</p><h1 id="nodejs后台配置"><a href="#nodejs后台配置" class="headerlink" title="nodejs后台配置"></a>nodejs后台配置</h1><h2 id="获得openid"><a href="#获得openid" class="headerlink" title="获得openid"></a>获得openid</h2><p>打开如下连接并重定向到redirect_uri后面的连接中<br>需要主要的是该链接需要进行加密<br>编码地址</p><blockquote><p><a href="http://tool.chinaz.com/tools/urlencode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/urlencode.aspx</a></p></blockquote><pre><code>    //例 1.1    //express示例代码    exports.bindWechat = function(req,res){        let state = req.query.state;        res.redirect(&#39;https://open.weixin.qq.com/connect/oauth2/authorize?appid=【微信AppID】&amp;redirect_uri=【https%3a%2f%2fwww.netrelay.cn%2fwechat】&amp;response_type=code&amp;scope=snsapi_base&amp;state=&#39;+state+&#39;#wechat_redirect&#39;);    }</code></pre><p>重定向后从query中取出code,你用request取出openid</p><pre><code>//例 1.2//express示例代码    let url = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=【微信AppID】&amp;secret=【微信secret】&amp;code=&quot;+req.query.code+&quot;&amp;grant_type=authorization_code&quot;;    request(url, function (error, response, body) {        let content = JSON.parse(body);        let openid = content.openid;    })</code></pre><h2 id="后台生成调起支付的必备参数"><a href="#后台生成调起支付的必备参数" class="headerlink" title="后台生成调起支付的必备参数"></a>后台生成调起支付的必备参数</h2><p>调用微信支付需要一系列的复杂步骤，这里直接引用工具类<a href="http://www.hhhub.cn:8000/f/2b36bc2325/?raw=1" target="_blank" rel="noopener">wxpay</a></p><pre><code>//例 1.3exports.gsmOrderPay = function (req, res, next) {    //以下几个参数看文档 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1    wxpay.orderWithDetail(attach,body,detail, mch_id, openid,bookingNo, total, notify_url).then(function(data){        res.json({            args: data        });    });};</code></pre><p>这里需要注意的是notify_url，这个连接需要是一个post接口.<br>在这里能够收到订单反馈的信息，并且需要上报给微信，否则微信会一直向接口发送post请求。</p><pre><code>//例 1.4exports.notify = function(req, res, next){    let info = req.body.xml;//微信订单返回的信息    res.end(wxpay.notify(req.body.xml));//回馈给微信})</code></pre><h1 id="前段配置"><a href="#前段配置" class="headerlink" title="前段配置"></a>前段配置</h1><p>前段需要引入jsapi</p><blockquote><script src="https://res.wx.qq.com/open/js/jweixin-1.2.0.js"></script></blockquote><p>发起支付</p><pre><code>    function payGsm() {        $.ajax({            url: &#39;/user/gsm_order/toPay&#39;,//这个post请求是请求到上面的例1.3            dataType: &quot;JSON&quot;,            type: &#39;POST&#39;,            data: {total:total},            success:function(data){                if (typeof WeixinJSBridge == &quot;undefined&quot;) {                    if (document.addEventListener) {                        document.addEventListener(&#39;WeixinJSBridgeReady&#39;, onBridgeReady, false);                    } else if (document.attachEvent) {                        document.attachEvent(&#39;WeixinJSBridgeReady&#39;, onBridgeReady);                        document.attachEvent(&#39;onWeixinJSBridgeReady&#39;, onBridgeReady);                    }                } else {                    //data.args的args来自于例1.3返回的args                    onBridgeReady(data.args);                }            },            error: function (err) {            }        });    }    function onBridgeReady(args) {        WeixinJSBridge.invoke(            &quot;getBrandWCPayRequest&quot;, {                &quot;appId&quot;: args.appId,     //公众号名称，由商户传入                &quot;timeStamp&quot;: args.timeStamp,         //时间戳，自1970年以来的秒数                &quot;nonceStr&quot;: args.nonceStr, //随机串                &quot;package&quot;: &quot;prepay_id=&quot;+args.package,                &quot;signType&quot;: args.signType, //微信签名方式：                &quot;paySign&quot;: args.paySign //微信签名,            }, function (res) {                //res.err_msg == &quot;get_brand_wcpay_request:ok&quot; 表示支付成功，按需处理结果                if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) {                    window.location.replace(&quot;/scan/callpay/gsm&quot;);                } else {                    window.location.replace(&quot;/scan/callpay/failed&quot;);                }            });    }</code></pre><p>比较乱，后面再重新整理，现做一下简单记录，防止忘了。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>微信</tag>
      
      <tag>支付</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-10-30</title>
    <link href="/2019/10/30/%E9%9A%8F%E7%AC%942019-10-30/"/>
    <url>/2019/10/30/%E9%9A%8F%E7%AC%942019-10-30/</url>
    
    <content type="html"><![CDATA[<p>最近这些天感觉好累，是秋乏吗？还是跑了点步？还是睡眠少了？</p><p>不知道什么原因，反正乏的很，躺在床上伸个懒腰就感觉很舒服。</p><p>左眼也感觉很累，想闭目养神，却又忍不住看手机。为了保护眼睛还是要少玩手机，把一些没什么必要的APP还是戒了吧，需要的时候再看，没必要的时候看看书，这不香吗？</p><p>上面的都是小事情，严重的是我前天跑步流鼻血，昨天嘴里吐出血。虽然我知道鼻血是我抠鼻屎导致的鼻黏膜损伤，吐血是因为牙龈出血或者嘴唇干裂出的血，但是还是很担心自己的健康。身体的革命的本钱，可不能再懒惰，运动什么的不能停，毕竟现在已经是一个190的大胖子了。</p><p>老婆的换岗终于成功了，许多波折总算完了，愿一切都好。</p><p>后天就是30岁的正生了，真是时光荏苒。我有时候就像一个鸵鸟一样，很多事情一想就会鼻子酸，于是立马分散注意力逃避掉那些伤感的事情，过好现在的生活。</p><p>最近这几年，也算过的顺风顺水吧，大问题基本没有，也愿往后的生活也能像现在这样有小烦恼但风平浪静。</p><p>最后跟自己打打气，提起精神，为生活努力！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx相关操作</title>
    <link href="/2019/10/23/Nginx%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <url>/2019/10/23/Nginx%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows开机启动"><a href="#Windows开机启动" class="headerlink" title="Windows开机启动"></a>Windows开机启动</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://www.hhhub.cn:8000/f/e64c77dfdb/?raw=1" target="_blank" rel="noopener">点击下载</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="将软件放到nginx目录-并将名称改为nginx-service-exe"><a href="#将软件放到nginx目录-并将名称改为nginx-service-exe" class="headerlink" title="将软件放到nginx目录,并将名称改为nginx-service.exe"></a>将软件放到nginx目录,并将名称改为nginx-service.exe</h3><h3 id="新建nginx-service-xml文件"><a href="#新建nginx-service-xml文件" class="headerlink" title="新建nginx-service.xml文件"></a>新建nginx-service.xml文件</h3><p>键入内容</p><pre><code>&lt;!-- nginx-service.xml --&gt;&lt;service&gt;    &lt;id&gt;nginx&lt;/id&gt;    &lt;name&gt;nginx&lt;/name&gt;    &lt;description&gt;nginx&lt;/description&gt;    &lt;logpath&gt;(填写nginx目录，如：D:nginx-1.14.0\)&lt;/logpath&gt;    &lt;logmode&gt;roll&lt;/logmode&gt;    &lt;depend&gt;&lt;/depend&gt;    &lt;executable&gt;(填写nginx目录和命令，如：D:nginx-1.14.0\nginx.exe)&lt;/executable&gt;    &lt;stopexecutable&gt;(填写nginx目录和命令，如：D:nginx-1.14.0\nginx.exe -s stop)&lt;/stopexecutable&gt;&lt;/service&gt;</code></pre><h3 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h3><p>在nginx文件夹根目录中打开命令行</p><pre><code>.\nginx-service.exe install </code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>.\nginx-service.exe start</code></pre><h1 id="Ubuntu下的操作"><a href="#Ubuntu下的操作" class="headerlink" title="Ubuntu下的操作"></a>Ubuntu下的操作</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><pre><code>sudo apt-get install nginx</code></pre><h2 id="自动启动服务"><a href="#自动启动服务" class="headerlink" title="自动启动服务"></a>自动启动服务</h2><pre><code>sudo systemctl enable nginx #开启服务sudo systemctl disable nginx #关闭服务</code></pre><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre><code>sudo systemctl start nginx  #启用nginx服务nginx #启动nginxnginx -s stop #停止nginxnginx -s reload #重启nginx</code></pre><h2 id="强行停止"><a href="#强行停止" class="headerlink" title="强行停止"></a>强行停止</h2><pre><code>ps -ef | grep nginx #查询进程IDkill -9 ID #强制停止</code></pre><h1 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h1><h2 id="ssh证书配置"><a href="#ssh证书配置" class="headerlink" title="ssh证书配置"></a>ssh证书配置</h2><p>按如下配置即可</p><pre><code>server {    listen 443 ssl;    server_name  www.xxx.cn; #域名    ssl_certificate xxx.cn.crt; #下载的证书，放在当前文件夹中    ssl_certificate_key xxx.cn.key; #下载的证书    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;    location / {        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;        proxy_http_version 1.1;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_pass http://127.0.0.1:1111; #指向后台程序        proxy_redirect off;    }}</code></pre><h2 id="80端口转443端口"><a href="#80端口转443端口" class="headerlink" title="80端口转443端口"></a>80端口转443端口</h2><p>之前APP是80端口，现在升级为HTTPS后，post请求变成GET了。<br>按如下配置判断是否是POST请求，如果是用原来的接口返回，否则转移到443</p><pre><code>server {    listen 80;    server_name www.xxx.cn;    location / {        if ($request_method ~ ^(POST)$) {            proxy_pass http://127.0.0.1:8765;            break ;        }        return 301 https://www.xxx.cn$request_uri;    }}</code></pre><p>如果不需要判断POST，直接替换为443即可</p><pre><code>server {    listen 80;    server_name www.xxx.cn;    return 301 https://www.xxx.cn$request_uri;}# 添加个443 server，和上面的443一致</code></pre><h2 id="上传图片太大，导致失败"><a href="#上传图片太大，导致失败" class="headerlink" title="上传图片太大，导致失败"></a>上传图片太大，导致失败</h2><p>需要在nginx配置文件中添加如下配置</p><pre><code>client_max_body_size 1024m; # 大小自己定#server {#    listen 80;#}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-10-23</title>
    <link href="/2019/10/23/%E9%9A%8F%E7%AC%942019-10-23/"/>
    <url>/2019/10/23/%E9%9A%8F%E7%AC%942019-10-23/</url>
    
    <content type="html"><![CDATA[<p>最近还是好事不断<br>我不是一个喜欢分享的人，连最近结婚我都没有发个朋友圈什么的。</p><p>但是今天老婆换岗了，那必须要纪念一下，因为意义比较重要。</p><ul><li>她不用坐柜了，客户千千万，什么类型的都有，所以每天遇到不开心的事情很正常。换岗了，就不用再去受这个罪了。</li><li>我也不用听她的抱怨了，虽然知道她很辛苦，但是真的已经听腻了，也没法呀。</li><li>国庆回来就一直想吃乌鱼片都没有去吃，今天就庆祝一下一起去吃喽。</li></ul><p>虽然现在很穷哦，但是相信一切都会变好起来了。</p><p>我自己的考研、减肥都要坚持住,一起加油吧！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>换岗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows安装Redis和添加开机启动服务</title>
    <link href="/2019/10/23/Windows%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2019/10/23/Windows%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<p>Windows上安装Redis和服务，做下记录</p><h3 id="下载Reis（版本3-2-100）"><a href="#下载Reis（版本3-2-100）" class="headerlink" title="下载Reis（版本3.2.100）"></a>下载Reis（版本3.2.100）</h3><p>也可以在github下载，就是太慢了<br><a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">GitHub下载</a><br>百度网盘下载<br>链接: <a href="https://pan.baidu.com/s/1AC_k0XnL8JnMOPDTA3cb_w" target="_blank" rel="noopener">https://pan.baidu.com/s/1AC_k0XnL8JnMOPDTA3cb_w</a> 提取码: bkjg</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>解压下载文件到指定目录<blockquote><p>不需要启动下面3步可以忽略</p></blockquote></li><li>进入Redis文件reids-server.exe的目录</li><li>在此文件夹打开命令行</li><li>输入reids-server.exe启动redis</li></ul><h3 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h3><p>进入redis根目录</p><pre><code>redis-server.exe --service-install redis.windows.conf</code></pre><p>服务安装成功</p><p>进入服务列表启动下服务完成操作</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-10-22</title>
    <link href="/2019/10/22/%E9%9A%8F%E7%AC%942019-10-22/"/>
    <url>/2019/10/22/%E9%9A%8F%E7%AC%942019-10-22/</url>
    
    <content type="html"><![CDATA[<p>我去查了下手机，大壮是2019-7-18号走的。<br>是的，我已经忘记了时间，所以我也以为我已经忘记了失去大壮的痛苦。<br><br><br>打开博客的相册，看到了大壮、大胖、虎喵，看到了我们过去在一起的日子，眼泪还是不争气的流了出来。<br><br><br>所有的美好，都一去不复返了…<br><br><br>我真的好懊悔，我对不起你们。<br><br><br>这一生，我辜负了你们，如果真的有来生，我希望大壮投胎到好的人家。<br><br><br>不想说了，就到这吧，太难受了。<br><br><br>思念之苦。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>想念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PM2开机启动</title>
    <link href="/2019/10/22/PM2%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <url>/2019/10/22/PM2%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Windows开机启动"><a href="#Windows开机启动" class="headerlink" title="Windows开机启动"></a>Windows开机启动</h2><ul><li>安装启动库</li></ul><pre><code>npm install pm2-windows-startup -g</code></pre><ul><li>执行命令</li></ul><pre><code>pm2-startup install</code></pre><ul><li>设置开机启动</li></ul><pre><code>pm2 start [程序]</code></pre><pre><code>pm2 startup</code></pre><pre><code>pm2 save</code></pre><h2 id="Linux开机启动"><a href="#Linux开机启动" class="headerlink" title="Linux开机启动"></a>Linux开机启动</h2><p>linux开机启动分为三步</p><pre><code>pm2 start [程序]</code></pre><pre><code>pm2 startup</code></pre><pre><code>pm2 save</code></pre><p>重启测试，如果不成功，根据提示操作即可。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pm2</tag>
      
      <tag>开机启动</tag>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建MQTT</title>
    <link href="/2019/07/04/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAMQTT/"/>
    <url>/2019/07/04/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAMQTT/</url>
    
    <content type="html"><![CDATA[<h2 id="Nodejs安装"><a href="#Nodejs安装" class="headerlink" title="Nodejs安装"></a>Nodejs安装</h2><p>*以下命令皆在命令行输入</p><ol><li>进入指定文件夹<br>cd /home/pi（也可以选择其他文件夹）</li><li><p>下载nodejs<br>Nodejs版本要选择armv71的</p><pre><code>wget https://nodejs.org/dist/v6.9.1/node-v6.9.1-linux-armv7l.tar.gz（版本号根据需要选择）</code></pre><p> 如果速度慢，可以自己去上面的网址下载</p></li><li><p>解压文件</p><pre><code>tar zxvf node-v6.9.1-linux-armv7l.tar.gz （文件名跟自己下载的相符）</code></pre></li><li><p>将解压好的nodejs剪切到下面的bin文件夹</p><pre><code>sudo mv node-v6.9.1-linux-armv7l  /usr/local/bin（文件名跟解压的相符）</code></pre></li><li><p>创建node快捷方式</p><pre><code>sudo ln /usr/local/bin/node-v6.9.1-linux-armv7l/bin/node /usr/local/bin/node（文件名跟解压的相符）</code></pre></li><li>创建npm快捷方式<pre><code>sudo ln -s /usr/local/bin/node-v6.9.1-linux-armv7l/lib/node_modules/npm/bin/npm /usr/local/bin/npm（文件名跟解压的相符）</code></pre></li></ol><p>正常是已经OK了，使用node –v和npm –v，发现npm找不到</p><p>将/usr/local/bin/node-v6.9.1-linux-armv7l/lib下的node_modules复制到/usr/local/bin下</p><p>进入/usr/local/bin文件夹</p><pre><code>cd  /usr/local/binsudo cp –r /usr/local/bin/node-v6.9.1-linux-armv7l/lib/node_modules /usr/local/bin</code></pre><p>已经就是nodejs配置完成</p><h2 id="Mqtt服务端安装"><a href="#Mqtt服务端安装" class="headerlink" title="Mqtt服务端安装"></a>Mqtt服务端安装</h2><p>新建一个js文件，输入如下测试代码：</p><pre><code>var mosca = require(&#39;mosca&#39;);  var MqttServer = new mosca.Server({  port: 1883  });  MqttServer.on(&#39;clientConnected&#39;, function(client){          console.log(&#39;client connected&#39;, client.id);  });  /**  * 监听MQTT主题消息  **/  MqttServer.on(&#39;published&#39;, function(packet, client) {      var topic = packet.topic;      console.log(&#39;message-arrived---&gt;&#39;,&#39;topic =&#39;+topic+&#39;,message = &#39;+ packet.payload.toString());  });  MqttServer.on(&#39;ready&#39;, function(){      console.log(&#39;mqtt is running...&#39;);      //MqttServer.authenticate = authenticate;  }); </code></pre><h2 id="安装mosca"><a href="#安装mosca" class="headerlink" title="安装mosca"></a>安装mosca</h2><pre><code>npm  i  mosca –save</code></pre><p>安装完成以后运行上面的代码完成。</p><h2 id="安装vnc-可选"><a href="#安装vnc-可选" class="headerlink" title="安装vnc(可选)"></a>安装vnc(可选)</h2><p>在树莓派安装vnc</p><pre><code>sudo apt-get install tightvncserver</code></pre><p>增加一个桌面</p><pre><code>Tightvncserver</code></pre><p>根据提示设置一个访问桌面的密码</p><p>根据提示设置一个仅能看树莓派着的密码</p><p>设置完成后，回到一个桌面的ID，例如是1</p><p>在windows打开vnc（如果未安装请自行安装），输入树莓派ip加桌面id，例如：192.168.0.102:1<br>输入密码访问密码</p><p>现在可以访问树莓派!</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>raspberry</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-04-18</title>
    <link href="/2019/04/18/%E9%9A%8F%E7%AC%942019-04-18/"/>
    <url>/2019/04/18/%E9%9A%8F%E7%AC%942019-04-18/</url>
    
    <content type="html"><![CDATA[<div style="width:100%" align="center"><br><video id="video" style="width:50%" controls preload="none" poster="https://bolg-1253436879.cos.ap-chengdu.myqcloud.com/1181555557840_.pic.jpg"><br>      <source id="mp4" src="https://bolg-1253436879.cos.ap-chengdu.myqcloud.com/1555556205683864.mp4" type="video/mp4"><br>      <p>视频</p><br></video><br></div>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>撸猫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-04-06</title>
    <link href="/2019/04/06/%E9%9A%8F%E7%AC%942019-04-06/"/>
    <url>/2019/04/06/%E9%9A%8F%E7%AC%942019-04-06/</url>
    
    <content type="html"><![CDATA[<p>清明时节雨纷纷，路上行人欲断魂。</p><p>今年的清明节有点儿反常，28℃的天气，热的有点儿烦躁。</p><p>有时候觉得偏心真是一件可怕的事情。<br>我现在深知自己对三只猫的爱不能够平均，即使我百般的对大壮好，但是在我心中的地位他还是不及虎喵和大胖。<br><a id="more"></a><br>我之前偏心是因为大壮跟我太疏远，对我有戒心，渐渐的我也就对他有了偏见。<br>经过了几年的相处，他对我虽然还有点儿戒备，但是基本上他已经是最粘我的那一个了，但是他在我心中的位置还是无法和其他两个对等。</p><p>我在我的家里，我是老小。所以一直以来我都是集万千宠爱于一身的，爸妈把他们的全部都给了我，甚至本该属于我姐姐的也都挤出来了给我。<br>一直以来我都觉得这没有什么，这是我应得的，父母的爱当然是没有错。</p><p>直到现在，我住在了我老婆家，终于我扮演的角色发生了改变。我不再是那个对别人偏心的角色，也不再是被偏心的那一个了。</p><p>每天看着老丈人对小姨子的溺爱以及对老婆的不公我心里就非常不舒服。<br>同样是女儿，他把所有的都给了小女儿。什么东西首先想到的都是小女儿，晚饭本来是留给老婆的他都要让他的小女儿吃足够了，反正大女儿要减肥？<br>早上煮个面，只煮了自己和小女儿的，自己大女儿那么喜欢吃面，不知道吗？多放几个面条会怎样？</p><p>但是，好像只有我一个人感受到了。</p><p>我现在终于能体会到，我的姐姐们之前应该也是这样过来的吧？毕竟我们是一个爹妈生的，我们的性格能差别多少呢？他们应该也像我一样强烈感受到了吧？</p><p>都30的人了，想到这些事还是会忍不住想哭。</p><p>希望我和我的小姨子都能明白父母是多么的偏心，以后要好好的对自己的姐姐，把本不属于自己的东西能够尽量还回去。</p><image src="https://bolg-1253436879.cos.ap-chengdu.myqcloud.com/1061554515804_.pic.jpg" style="width:100%;height:auto"></image>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>偏心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async模块使用</title>
    <link href="/2019/03/21/async%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/03/21/async%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><h3 id="异步循环操作"><a href="#异步循环操作" class="headerlink" title="异步循环操作"></a>异步循环操作</h3><p>示例</p><pre><code>const async = require(&#39;async&#39;);const axios = require(&#39;axios&#39;);//计数let count = 0;//测试数据var urlList = [&#39;test1.html&#39;,&#39;test2.html&#39;,&#39;test3.html&#39;,&#39;test4.html&#39;,&#39;test5.html&#39;];//执行方法let action = function(callback){    //测试数据    console.log(urlList[count]);    //异步请求    axios.get(&#39;https://hhclub.net/api/v1/getVideos&#39;)    .then(function(res){        //执行完数量加1        count++;        console.dir(count);        //回调函数        callback(null,count);    })}//计数方法let countFunc = function(){    //小于多少就执行多少次，如这里是执行5次    return count &lt; 5;}//开始执行，使用whilst方法async.whilst(countFunc,action,function(err){    if (err) {        console.dir(err);    }    console.log(&#39;结束&#39;)})</code></pre><p>打印结果</p><pre><code>test1.html1test2.html2test3.html3test4.html4test5.html5结束</code></pre><h3 id="添加延迟"><a href="#添加延迟" class="headerlink" title="添加延迟"></a>添加延迟</h3><p>示例</p><pre><code>var async = require(&#39;async&#39;);let action1 = function(callback){    console.log(&#39;执行时间：&#39;+new Date().getTime());    callback(null,&#39;action1&#39;);}let action2 = function(callback){    console.log(&#39;执行时间：&#39;+new Date().getTime());    callback(null,&#39;action2&#39;);}let action3 = function(callback){    console.log(&#39;执行时间：&#39;+new Date().getTime());    callback(null,&#39;action3&#39;);}let action4 = function(callback){    console.log(&#39;执行时间：&#39;+new Date().getTime());    callback(null,&#39;action4&#39;);}let delay = function(callback){    setTimeout(function(){        callback(null,&#39;delay&#39;);    },2000)}async.series([action1,delay,action2,delay,action3,delay,action4,delay],function(err){    if (err) {        console.dir(err);    }    console.log(&#39;结束&#39;+new Date().getTime())})</code></pre><p>打印结果</p><pre><code>执行时间：1553185376354执行时间：1553185378362执行时间：1553185380365执行时间：1553185382371结束1553185384373</code></pre><h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><p>并行执行和顺序执行类似，并行执行是多个函数同时运行，最后一个执行完后结束</p><p>使用方法</p><pre><code>parallel(tasks,[callback])</code></pre><h2 id="瀑布流执行"><a href="#瀑布流执行" class="headerlink" title="瀑布流执行"></a>瀑布流执行</h2><p>下一个函数需要上一个执行结果</p><p>使用方法</p><pre><code>waterfall(tasks,[callback])</code></pre><p>示例</p><pre><code>var task1 =function(callback){    console.log(&quot;task1&quot;);    callback(null,&quot;11&quot;)}//param为第一个函数的结果var task2 =function(param,callback){    console.log(&quot;task2&quot;);    callback(null,&quot;22&quot;)}async.waterfall([task1,task2],function(err,result){    if (err) {        console.log(err);    }    console.log(&quot;result : &quot;+result);})</code></pre><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>可以用作循环加延迟</p><p>使用方法</p><pre><code>forever([callback])</code></pre><p>示例</p><pre><code>var async = require(&#39;async&#39;);var count = 0;async.forever(function(callback){    console.log(&quot;当前结果：&quot;+new Date().getTime());    count++;    if (count&gt;10) {        callback(&quot;finish&quot;);        return;    }    //添加一秒延迟    setTimeout(function () {        callback();    },1000)},function(err){    console.log(err);});</code></pre><p>输出结果</p><pre><code>当前结果：1553186956484当前结果：1553186957494当前结果：1553186958496当前结果：1553186959499当前结果：1553186960501当前结果：1553186961503当前结果：1553186962505当前结果：1553186963510当前结果：1553186964516当前结果：1553186965519当前结果：1553186966524finish</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sequelize常用功能</title>
    <link href="/2019/03/21/Sequelize%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    <url>/2019/03/21/Sequelize%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm i sequelize --save</code></pre><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><pre><code>global.seq =  new Sequelize(&#39;数据库名称&#39;, &#39;用户名&#39;, &#39;密码&#39;,{    host: &#39;数据库地址（如：127.0.0.1）&#39;,    dialect: &#39;数据库类型（如：mysql）&#39;,    port: 数据库端口（如：3306）,    pool: {//线程池配置        max: 5,        min: 0,        idle: 30000    },    logging:true,//是否在控制台打印sql语句    timezone: &#39;+08:00&#39; //东八时区，不设置存入数据库的时间可能不对});</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>seq.define(&#39;test&#39;, {    // auto increment, primaryKey, unique    id: {type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true, unique: true},    updatedAt: {type: Sequelize.INTEGER, allowNull: false},    createdAt: {type: Sequelize.INTEGER, allowNull: false}}, {    timestamps: true,//设置为true，自动设置update和create    freezeTableName: true//设置为true，表的名字和数据库一直，否则要变成复数加s});</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="order排序"><a href="#order排序" class="headerlink" title="order排序"></a>order排序</h3><pre><code>CameraList.findAll({    where:{        account:user    },    order: [        [&#39;timestamp&#39;, &#39;ASC&#39;],//第一字段        [&#39;name&#39;,&#39;ASC&#39;]//第二字段    ]})</code></pre><h3 id="where条件"><a href="#where条件" class="headerlink" title="where条件"></a>where条件</h3><pre><code>Project.findAll({  where: {    id: {      $and: {a: 5}           // AND (a = 5)      $or: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)      $gt: 6,                // id &gt; 6      $gte: 6,               // id &gt;= 6      $lt: 10,               // id &lt; 10      $lte: 10,              // id &lt;= 10      $ne: 20,               // id != 20      $between: [6, 10],     // BETWEEN 6 AND 10      $notBetween: [11, 15], // NOT BETWEEN 11 AND 15      $in: [1, 2],           // IN [1, 2]      $notIn: [1, 2],        // NOT IN [1, 2]      $like: &#39;%hat&#39;,         // LIKE &#39;%hat&#39;      $notLike: &#39;%hat&#39;       // NOT LIKE &#39;%hat&#39;      $iLike: &#39;%hat&#39;         // ILIKE &#39;%hat&#39; (case insensitive)  (PG only)      $notILike: &#39;%hat&#39;      // NOT ILIKE &#39;%hat&#39;  (PG only)      $overlap: [1, 2]       // &amp;&amp; [1, 2] (PG array overlap operator)      $contains: [1, 2]      // @&gt; [1, 2] (PG array contains operator)      $contained: [1, 2]     // &lt;@ [1, 2] (PG array contained by operator)      $any: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)    },    status: {      $not: false,           // status NOT FALSE    }  }})</code></pre><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><pre><code>Project.findAll({ where: [&quot;id &gt; ?&quot;, 25] }).then(function(projects) {  // projects 是一个包含 Project 实例的数组，各实例的id 大于25})</code></pre><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><pre><code>//求和Project.sum(&#39;field&#39;, where:{--条件--}  }).then(function(sum) {  // 输出和})//maxProject.max(&#39;field&#39;, where:{--条件--}  }).then(function(max) {  // 输出最大值})//minProject.min(&#39;field&#39;, where:{--条件--}  }).then(function(max) {  // 输出最小值})</code></pre><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><pre><code>//调用Sequelize初始化之后的sequelize对象sequelize.transaction(function (t) {    //返回最终的Promise  return User.create({    firstName: &#39;Abraham&#39;,    lastName: &#39;Lincoln&#39;  }, {transaction: t}).then(function (user) {    return user.setShooter({      firstName: &#39;John&#39;,      lastName: &#39;Boothe&#39;    }, {transaction: t});  });}).then(function (result) {  //主动调用commit提交结果  return t.commit();}).catch(function (err) {  //主动回滚操作  return t.rollback();});</code></pre><h2 id="sequelize在eggjs中的应用"><a href="#sequelize在eggjs中的应用" class="headerlink" title="sequelize在eggjs中的应用"></a>sequelize在eggjs中的应用</h2><h3 id="Op属性的运用"><a href="#Op属性的运用" class="headerlink" title="Op属性的运用"></a>Op属性的运用</h3><ul><li>gt、lt的使用 </li></ul><pre><code>  GsmCard.getWillExpire = async function(offset, limit, timestamp) {    console.log(&#39;ddd&#39; + timestamp);    return await this.findAndCountAll({      where: {        expiry_date: {          [Op.lt]: timestamp,        },      },      offset: Number(offset),//偏移量      limit: Number(limit),//数量    });  };</code></pre><ul><li>or的使用</li></ul><pre><code>  Account.getRootAccounts = async function() {    return await this.findAll({      where: {        [Op.or]: [          { type: &#39;admin&#39; }, { type: &#39;root&#39; },        ],      },    });  };</code></pre><h3 id="DISTINCT用法"><a href="#DISTINCT用法" class="headerlink" title="DISTINCT用法"></a>DISTINCT用法</h3><pre><code>    return await this.findAll({      attributes: [[ app.Sequelize.fn(&#39;DISTINCT&#39;, app.Sequelize.col(&#39;devicegroup&#39;)), &#39;devicegroup&#39; ]],      where: {        wechat,      },    });</code></pre><h2 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h2><blockquote><p><a href="https://itbilu.com/nodejs/npm/V1PExztfb.html" target="_blank" rel="noopener">https://itbilu.com/nodejs/npm/V1PExztfb.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>sequelize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔2019-03-20</title>
    <link href="/2019/03/20/%E9%9A%8F%E7%AC%942019-03-20/"/>
    <url>/2019/03/20/%E9%9A%8F%E7%AC%942019-03-20/</url>
    
    <content type="html"><![CDATA[<p>每天最幸福的事情就是一边上班一边撸猫了。</p><p>今天终于又把blog给重新搭起来了，之前的又白写了，因为源文件被我给删了。</p><p>不过也罢，反正是写的东西也不是很有价值…</p><p>之所以想起来重新弄博客的初衷，竟然是为了学习Flutter！</p><p>希望这次自己能够记录一些有价值的东西，包括生活和学习…</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>撸猫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
